import { createHash } from "crypto";
import { accessSync, constants, existsSync, mkdirSync, readFileSync, writeFileSync } from "fs";
import { dirname, isAbsolute, join, relative, resolve, sep } from "path";
import { CliError } from "../lib/errors.ts";
import { parseSemicolonList } from "../lib/strings.ts";
import { parseIsoTimestampOrThrow, resolveNow } from "../lib/time.ts";
import { sortKeys, stableStringify, toRepoRelative } from "../skill/skill-io.ts";

type CommandContext = {
  rootDir: string;
};

type LogWorkInput = {
  method: string;
  roleAssignment: string;
  context: string;
  action: string;
  methodPath?: string;
  outputs: string[];
  decisions: string[];
  timestampStart?: string;
};

type LogWorkResult = {
  workRecordPath: string;
  created: string[];
  warnings: Array<{ code: string; message: string }>;
};

export async function runLogWorkAsync(
  ctx: CommandContext,
  argv: string[],
): Promise<{ exitCode: number; json: unknown; stdout: string[]; stderr: string[] }> {
  const stdout: string[] = [];
  const stderr: string[] = [];

  const input = parseArgs(argv);
  ensureRootWritable(ctx.rootDir);

  const warnings: Array<{ code: string; message: string }> = [];
  const work = await logWorkAsync({ rootDir: ctx.rootDir, input, warnings, silent: false, stdout, stderr });

  const result: LogWorkResult = { workRecordPath: work.workRecordPath, created: [work.workRecordPath], warnings };

  return {
    exitCode: 0,
    json: { ok: true, command: "log-work", root: ctx.rootDir, ...result },
    stdout: [`Work Logged: ${work.workRecordPath}`],
    stderr: warnings.map((w) => `WARN: ${w.message}`),
  };
}

export async function logWorkAsync(input: {
  rootDir: string;
  input: LogWorkInput;
  warnings: Array<{ code: string; message: string }>;
  silent: boolean;
  stdout: string[];
  stderr: string[];
}): Promise<{ workRecordPath: string }> {
  const rootDir = input.rootDir;

  const methodRef = resolveMethodDescriptionRef(input.input.method, input.input.methodPath, rootDir);

  const outputs = input.input.outputs.map((entry) => normalizeArtifactRef(entry, rootDir));
  const relatedDecisions = input.input.decisions.map((entry) => normalizeArtifactRef(entry, rootDir));

  const timestampStart = resolveTimestampStart(input.input.timestampStart);
  const isoTimestamp = timestampStart.toISOString();
  const timestamp = isoTimestamp.replace(/[:.]/g, "-");

  const targetDir = join(rootDir, "runtime", "contexts", input.input.context, "telemetry", "work");
  mkdirSync(targetDir, { recursive: true });

  const filename = `work-${timestamp}.md`;
  const absPath = join(targetDir, filename);
  const relPath = toRepoRelative(absPath, rootDir);

  if (existsSync(absPath)) {
    throw new CliError("ALREADY_EXISTS", `Work record already exists at ${relPath}`, 1);
  }

  const inputsDigest = computeInputsDigest({
    methodDescriptionRef: methodRef,
    roleAssignmentRef: input.input.roleAssignment,
    context: input.input.context,
    action: input.input.action,
    outputs,
    relatedDecisions,
  });

  const content = `---
type: U.Work
timestamp_start: ${JSON.stringify(isoTimestamp)}
context: ${JSON.stringify(input.input.context)}
method_description_ref:
${renderMethodDescriptionRefYaml(methodRef)}
role_assignment_ref: ${JSON.stringify(input.input.roleAssignment)}
inputs_digest: ${JSON.stringify(inputsDigest)}
outputs: ${renderYamlStringList(outputs)}
related_decisions: ${renderYamlStringList(relatedDecisions)}
---

# U.Work: Execution of ${input.input.method}

## 1. Links
- **MethodDescription**: \`${methodRef.id}${methodRef.version ? ` (v${methodRef.version})` : ""}\`
- **RoleAssignment**: \`${input.input.roleAssignment}\`
- **Context**: \`${input.input.context}\`
- **InputsDigest**: \`${inputsDigest}\`

## 2. Occurrence
${input.input.action}

## 3. Outputs
${renderMarkdownList(outputs)}

## 4. Related Decisions
${renderMarkdownList(relatedDecisions)}

## 5. Evidence
- **Trace**: Generated by \`telemetry/log-work\`
`;

  writeFileSync(absPath, content, "utf8");

  await emitPosthogEvent(
    {
      method: methodRef.id,
      roleAssignment: input.input.roleAssignment,
      context: input.input.context,
      action: input.input.action,
      outputsCount: outputs.length,
      timestamp: isoTimestamp,
    },
    (warning) => input.warnings.push(warning),
  );

  return { workRecordPath: relPath };
}

type LogWorkArgs = {
  method: string;
  roleAssignment: string;
  context: string;
  action: string;
  methodPath?: string;
  outputs: string[];
  decisions: string[];
  timestampStart?: string;
};

function parseArgs(argv: string[]): LogWorkArgs {
  let method = "";
  let roleAssignment = "";
  let context = "";
  let action = "";
  let methodPath: string | undefined;
  let outputs: string[] = [];
  let decisions: string[] = [];
  let timestampStart: string | undefined;

  for (let i = 0; i < argv.length; i += 1) {
    const arg = argv[i];

    if (arg === "-h" || arg === "--help") {
      throw new CliError(
        "HELP",
        [
          "Usage: fpf log-work --method <id> --role-assignment <assigned> --context <ctx> --action <desc> [options]",
          "",
          "Options:",
          "  --method <id>            MethodDescription identifier (alias: --spec)",
          "  --method-path <path>     Optional repo-relative path to the method SkillSpec",
          "  --role-assignment <ref>  RoleAssignment reference (alias: --role)",
          "  --context <ctx>          Bounded context (safe path segment)",
          "  --action <text>          Description of the work performed",
          "  --outputs \"a; b\"         Semicolon-delimited output paths",
          "  --decisions \"x; y\"       Semicolon-delimited DRR ids/paths",
          "  --timestamp-start <iso>  ISO-8601 timestamp override (for deterministic runs)",
        ].join("\n"),
        0,
      );
    }

    if (arg === "--method" || arg === "--spec") {
      method = requireArgValue(argv, i, arg);
      i += 1;
      continue;
    }
    if (arg === "--method-path") {
      methodPath = requireArgValue(argv, i, arg);
      i += 1;
      continue;
    }
    if (arg === "--role-assignment" || arg === "--role") {
      roleAssignment = requireArgValue(argv, i, arg);
      i += 1;
      continue;
    }
    if (arg === "--context") {
      context = requireArgValue(argv, i, arg);
      i += 1;
      continue;
    }
    if (arg === "--action") {
      action = requireArgValue(argv, i, arg);
      i += 1;
      continue;
    }
    if (arg === "--outputs") {
      outputs = parseSemicolonList(requireArgValue(argv, i, arg));
      i += 1;
      continue;
    }
    if (arg === "--decisions") {
      decisions = parseSemicolonList(requireArgValue(argv, i, arg));
      i += 1;
      continue;
    }
    if (arg === "--timestamp-start") {
      timestampStart = requireArgValue(argv, i, arg);
      i += 1;
      continue;
    }

    throw new CliError("UNKNOWN_ARG", `Unknown argument '${arg}'.`, 1);
  }

  const methodValue = requireNonEmpty(method, "method");
  const roleValue = requireNonEmpty(roleAssignment, "role-assignment");
  const actionValue = requireNonEmpty(action, "action");
  const contextValue = requireMatch(context, /^[A-Za-z0-9][A-Za-z0-9_-]*$/, "context", "a safe path segment (letters, digits, '_' or '-')");

  return {
    method: methodValue,
    roleAssignment: roleValue,
    action: actionValue,
    context: contextValue,
    methodPath: methodPath?.trim().length ? methodPath.trim() : undefined,
    outputs,
    decisions,
    timestampStart: timestampStart?.trim().length ? timestampStart.trim() : undefined,
  };
}

function ensureRootWritable(rootDir: string): void {
  if (!existsSync(rootDir)) {
    throw new CliError("ROOT_NOT_FOUND", `Root not found: ${rootDir}`, 1);
  }
  try {
    accessSync(rootDir, constants.W_OK);
  } catch {
    throw new CliError("ROOT_NOT_WRITABLE", `Root is not writable: ${rootDir}`, 1);
  }
}

function requireArgValue(argv: string[], index: number, name: string): string {
  const value = argv[index + 1];
  if (!value || value.startsWith("-")) {
    throw new CliError("MISSING_ARG", `Missing value for ${name}.`, 1);
  }
  return value;
}

function requireNonEmpty(value: string | undefined, name: string): string {
  const trimmed = (value ?? "").trim();
  if (trimmed.length === 0) {
    throw new CliError("MISSING_ARG", `Missing ${name}.`, 1);
  }
  return trimmed;
}

function requireMatch(value: string | undefined, pattern: RegExp, name: string, description: string): string {
  const trimmed = (value ?? "").trim();
  if (trimmed.length === 0 || !pattern.test(trimmed)) {
    throw new CliError("INVALID_ARG", `Invalid ${name} '${value ?? ""}'. Expected ${description}.`, 1);
  }
  return trimmed;
}

type MethodDescriptionRef = {
  id: string;
  path?: string;
  version?: string;
};

function resolveMethodDescriptionRef(methodId: string, explicitPath: string | undefined, rootDir: string): MethodDescriptionRef {
  let resolvedPath: string | undefined;

  const trimmedPath = (explicitPath ?? "").trim();
  if (trimmedPath.length > 0) {
    const candidate = resolve(rootDir, trimmedPath);
    if (!existsSync(candidate)) {
      throw new CliError("INVALID_ARG", `Invalid method-path '${explicitPath}'. File not found.`, 1);
    }
    resolvedPath = toRepoRelative(candidate, rootDir);
  } else {
    const candidate = join(rootDir, "design", "skills", ...methodId.split("/"), "skill.json");
    if (existsSync(candidate)) {
      resolvedPath = toRepoRelative(candidate, rootDir);
    }
  }

  let version: string | undefined;
  if (resolvedPath) {
    try {
      const fullPath = resolve(rootDir, resolvedPath);
      const parsed = JSON.parse(readFileSync(fullPath, "utf8")) as Record<string, unknown>;
      if (typeof parsed.version === "string" && parsed.version.trim().length > 0) {
        version = parsed.version.trim();
      }
    } catch {
      // Optional enrichment only.
    }
  }

  return {
    id: methodId,
    ...(resolvedPath ? { path: resolvedPath } : {}),
    ...(version ? { version } : {}),
  };
}

function normalizeArtifactRef(value: string, rootDir: string): string {
  const trimmed = value.trim();
  if (trimmed.length === 0) return trimmed;

  const absolute = isAbsolute(trimmed) ? trimmed : resolve(rootDir, trimmed);
  const rel = relative(rootDir, absolute);
  const isOutsideRoot = isAbsolute(rel) || rel === ".." || rel.startsWith(`..${sep}`);
  if (!isOutsideRoot) {
    return toRepoRelative(absolute, rootDir);
  }

  return trimmed;
}

type InputsDigestPayload = {
  methodDescriptionRef: MethodDescriptionRef;
  roleAssignmentRef: string;
  context: string;
  action: string;
  outputs: string[];
  relatedDecisions: string[];
};

function computeInputsDigest(payload: InputsDigestPayload): string {
  const canonical = stableStringify(sortKeys(payload));
  return `sha256:${createHash("sha256").update(canonical, "utf8").digest("hex")}`;
}

function renderYamlStringList(values: string[]): string {
  if (values.length === 0) {
    return "[]";
  }
  return `\n${values.map((value) => `  - ${JSON.stringify(value)}`).join("\n")}`;
}

function renderMarkdownList(values: string[]): string {
  if (values.length === 0) {
    return "- (none)";
  }
  return values.map((value) => `- \`${value}\``).join("\n");
}

function renderMethodDescriptionRefYaml(value: MethodDescriptionRef): string {
  const lines = [`  id: ${JSON.stringify(value.id)}`];
  if (value.path && value.path.trim().length > 0) {
    lines.push(`  path: ${JSON.stringify(value.path.trim())}`);
  }
  if (value.version && value.version.trim().length > 0) {
    lines.push(`  version: ${JSON.stringify(value.version.trim())}`);
  }
  return lines.join("\n");
}

function resolveTimestampStart(explicitValue?: string): Date {
  const explicit = (explicitValue ?? "").trim();
  if (explicit.length > 0) {
    return parseIsoTimestampOrThrow(explicit, `timestamp-start '${explicitValue}'`);
  }
  return resolveNow();
}

type PosthogEvent = {
  method: string;
  roleAssignment: string;
  context: string;
  action: string;
  outputsCount: number;
  timestamp: string;
};

async function emitPosthogEvent(event: PosthogEvent, warn: (warning: { code: string; message: string }) => void): Promise<void> {
  const apiKey = process.env.POSTHOG_API_KEY?.trim();
  const distinctId = process.env.POSTHOG_DISTINCT_ID?.trim();
  if (!apiKey || !distinctId) {
    return;
  }

  const host = (process.env.POSTHOG_HOST ?? "https://app.posthog.com").trim();
  let url: URL;
  try {
    url = new URL("/capture", host);
  } catch {
    warn({ code: "POSTHOG_HOST_INVALID", message: `Invalid POSTHOG_HOST '${host}'.` });
    return;
  }

  const includeAction = process.env.POSTHOG_INCLUDE_ACTION === "1";
  const properties: Record<string, unknown> = {
    method: event.method,
    context: event.context,
    outputs_count: event.outputsCount,
    action_length: event.action.length,
    action_included: includeAction,
  };
  if (includeAction) {
    properties.action = event.action;
    properties.role_assignment = event.roleAssignment;
  }

  const payload = JSON.stringify({
    api_key: apiKey,
    event: "u_work_logged",
    distinct_id: distinctId,
    properties,
    timestamp: event.timestamp,
  });

  const controller = new AbortController();
  const timeout = setTimeout(() => controller.abort(), 2000);

  try {
    const response = await fetch(url, {
      method: "POST",
      headers: { "content-type": "application/json" },
      body: payload,
      signal: controller.signal,
    });
    if (!response.ok) {
      warn({ code: "POSTHOG_CAPTURE_FAILED", message: `PostHog capture failed (${response.status}).` });
    }
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    warn({ code: "POSTHOG_CAPTURE_FAILED", message: `PostHog capture failed (${message}).` });
  } finally {
    clearTimeout(timeout);
  }
}
